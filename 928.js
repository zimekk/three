(self.webpackChunk_dev_web=self.webpackChunk_dev_web||[]).push([[928],{4928:(t,e,s)=>{"use strict";s.d(e,{vc:()=>S,q_:()=>gt});var i=s(2312),n=s(2784),o=s(9461);function r(){return(r=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(t[i]=s[i])}return t}).apply(this,arguments)}function a(t,...e){return i.is.fun(t)?t(...e):t}const u=(t,e)=>!0===t||!!(e&&t&&(i.is.fun(t)?t(e):(0,i.qo)(t).includes(e))),c=(t,e)=>i.is.obj(t)?e&&t[e]:t,h=(t,e)=>!0===t.default?t[e]:t.default?t.default[e]:void 0,d=t=>t,l=(t,e=d)=>{let s=p;t.default&&!0!==t.default&&(t=t.default,s=Object.keys(t));const n={};for(const o of s){const s=e(t[o],o);i.is.und(s)||(n[o]=s)}return n},p=["config","onProps","onStart","onChange","onPause","onResume","onRest"],f={config:1,from:1,to:1,ref:1,loop:1,reset:1,pause:1,cancel:1,reverse:1,immediate:1,default:1,delay:1,onProps:1,onStart:1,onChange:1,onPause:1,onResume:1,onRest:1,onResolve:1,items:1,trail:1,sort:1,expires:1,initial:1,enter:1,update:1,leave:1,children:1,onDestroyed:1,keys:1,callId:1,parentId:1};function m(t){const e=function(t){const e={};let s=0;if((0,i.rU)(t,((t,i)=>{f[i]||(e[i]=t,s++)})),s)return e}(t);if(e){const s={to:e};return(0,i.rU)(t,((t,i)=>i in e||(s[i]=t))),s}return r({},t)}function y(t){return t=(0,i.je)(t),i.is.arr(t)?t.map(y):(0,i.Df)(t)?i.OH.createStringInterpolator({range:[0,1],output:[t,t]})(1):t}function g(t){for(const e in t)return!0;return!1}function _(t){return i.is.fun(t)||i.is.arr(t)&&i.is.obj(t[0])}function v(t,e){var s;null==(s=t.ref)||s.delete(t),null==e||e.delete(t)}function b(t,e){var s;e&&t.ref!==e&&(null==(s=t.ref)||s.delete(t),e.add(t),t.ref=e)}const S={default:{tension:170,friction:26},gentle:{tension:120,friction:14},wobbly:{tension:180,friction:12},stiff:{tension:210,friction:20},slow:{tension:280,friction:60},molasses:{tension:280,friction:120}},P=r({},S.default,{mass:1,damping:1,easing:t=>t,clamp:!1});class w{constructor(){this.tension=void 0,this.friction=void 0,this.frequency=void 0,this.damping=void 0,this.mass=void 0,this.velocity=0,this.restVelocity=void 0,this.precision=void 0,this.progress=void 0,this.duration=void 0,this.easing=void 0,this.clamp=void 0,this.bounce=void 0,this.decay=void 0,this.round=void 0,Object.assign(this,P)}}function j(t,e){if(i.is.und(e.decay)){const s=!i.is.und(e.tension)||!i.is.und(e.friction);!s&&i.is.und(e.frequency)&&i.is.und(e.damping)&&i.is.und(e.mass)||(t.duration=void 0,t.decay=void 0),s&&(t.frequency=void 0)}else t.duration=void 0}const C=[];class I{constructor(){this.changed=!1,this.values=C,this.toValues=null,this.fromValues=C,this.to=void 0,this.from=void 0,this.config=new w,this.immediate=!1}}function k(t,{key:e,props:s,defaultProps:n,state:o,actions:c}){return new Promise(((h,d)=>{var l;let p,f,m=u(null!=(l=s.cancel)?l:null==n?void 0:n.cancel,e);if(m)_();else{i.is.und(s.pause)||(o.paused=u(s.pause,e));let t=null==n?void 0:n.pause;!0!==t&&(t=o.paused||u(t,e)),p=a(s.delay||0,e),t?(o.resumeQueue.add(g),c.pause()):(c.resume(),g())}function y(){o.resumeQueue.add(g),o.timeouts.delete(f),f.cancel(),p=f.time-i.Wn.now()}function g(){p>0?(f=i.Wn.setTimeout(_,p),o.pauseQueue.add(y),o.timeouts.add(f)):_()}function _(){o.pauseQueue.delete(y),o.timeouts.delete(f),t<=(o.cancelId||0)&&(m=!0);try{c.start(r({},s,{callId:t,cancel:m}),h)}catch(t){d(t)}}}))}const q=(t,e)=>1==e.length?e[0]:e.some((t=>t.cancelled))?V(t.get()):e.every((t=>t.noop))?O(t.get()):R(t.get(),e.every((t=>t.finished))),O=t=>({value:t,noop:!0,finished:!0,cancelled:!1}),R=(t,e,s=!1)=>({value:t,finished:e,cancelled:s}),V=t=>({value:t,cancelled:!0,finished:!1});function T(t,e,s,n){const{callId:o,parentId:a,onRest:u}=e,{asyncTo:c,promise:h}=s;return a||t!==c||e.reset?s.promise=(async()=>{s.asyncId=o,s.asyncTo=t;const d=l(e,((t,e)=>"onRest"===e?void 0:t));let p,f;const m=new Promise(((t,e)=>(p=t,f=e))),y=t=>{const e=o<=(s.cancelId||0)&&V(n)||o!==s.asyncId&&R(n,!1);if(e)throw t.result=e,f(t),t},g=(t,e)=>{const a=new U,u=new A;return(async()=>{if(i.OH.skipAnimation)throw M(s),u.result=R(n,!1),f(u),u;y(a);const c=i.is.obj(t)?r({},t):r({},e,{to:t});c.parentId=o,(0,i.rU)(d,((t,e)=>{i.is.und(c[e])&&(c[e]=t)}));const h=await n.start(c);return y(a),s.paused&&await new Promise((t=>{s.resumeQueue.add(t)})),h})()};let _;if(i.OH.skipAnimation)return M(s),R(n,!1);try{let e;e=i.is.arr(t)?(async t=>{for(const e of t)await g(e)})(t):Promise.resolve(t(g,n.stop.bind(n))),await Promise.all([e.then(p),m]),_=R(n.get(),!0,!1)}catch(t){if(t instanceof U)_=t.result;else{if(!(t instanceof A))throw t;_=t.result}}finally{o==s.asyncId&&(s.asyncId=a,s.asyncTo=a?c:void 0,s.promise=a?h:void 0)}return i.is.fun(u)&&i.Wn.batchedUpdates((()=>{u(_,n,n.item)})),_})():h}function M(t,e){(0,i.yl)(t.timeouts,(t=>t.cancel())),t.pauseQueue.clear(),t.resumeQueue.clear(),t.asyncId=t.asyncTo=t.promise=void 0,e&&(t.cancelId=e)}class U extends Error{constructor(){super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."),this.result=void 0}}class A extends Error{constructor(){super("SkipAnimationSignal"),this.result=void 0}}const x=t=>t instanceof z;let Q=1;class z extends i.B0{constructor(...t){super(...t),this.id=Q++,this.key=void 0,this._priority=0}get priority(){return this._priority}set priority(t){this._priority!=t&&(this._priority=t,this._onPriorityChange(t))}get(){const t=(0,o.ys)(this);return t&&t.getValue()}to(...t){return i.OH.to(this,t)}interpolate(...t){return(0,i.LW)(),i.OH.to(this,t)}toJSON(){return this.get()}observerAdded(t){1==t&&this._attach()}observerRemoved(t){0==t&&this._detach()}_attach(){}_detach(){}_onChange(t,e=!1){(0,i.k0)(this,{type:"change",parent:this,value:t,idle:e})}_onPriorityChange(t){this.idle||i.fT.sort(this),(0,i.k0)(this,{type:"priority",parent:this,priority:t})}}const H=Symbol.for("SpringPhase"),W=t=>(1&t[H])>0,N=t=>(2&t[H])>0,E=t=>(4&t[H])>0,D=(t,e)=>e?t[H]|=3:t[H]&=-3,$=(t,e)=>e?t[H]|=4:t[H]&=-5;class X extends z{constructor(t,e){if(super(),this.key=void 0,this.animation=new I,this.queue=void 0,this.defaultProps={},this._state={paused:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set},this._pendingCalls=new Set,this._lastCallId=0,this._lastToId=0,this._memoizedDuration=0,!i.is.und(t)||!i.is.und(e)){const s=i.is.obj(t)?r({},t):r({},e,{from:t});i.is.und(s.default)&&(s.default=!0),this.start(s)}}get idle(){return!(N(this)||this._state.asyncTo)||E(this)}get goal(){return(0,i.je)(this.animation.to)}get velocity(){const t=(0,o.ys)(this);return t instanceof o.iG?t.lastVelocity||0:t.getPayload().map((t=>t.lastVelocity||0))}get hasAnimated(){return W(this)}get isAnimating(){return N(this)}get isPaused(){return E(this)}advance(t){let e=!0,s=!1;const n=this.animation;let{config:r,toValues:a}=n;const u=(0,o.He)(n.to);!u&&(0,i.j$)(n.to)&&(a=(0,i.qo)((0,i.je)(n.to))),n.values.forEach(((c,h)=>{if(c.done)return;const d=c.constructor==o.eC?1:u?u[h].lastPosition:a[h];let l=n.immediate,p=d;if(!l){if(p=c.lastPosition,r.tension<=0)return void(c.done=!0);let e=c.elapsedTime+=t;const s=n.fromValues[h],o=null!=c.v0?c.v0:c.v0=i.is.arr(r.velocity)?r.velocity[h]:r.velocity;let a;if(i.is.und(r.duration))if(r.decay){const t=!0===r.decay?.998:r.decay,i=Math.exp(-(1-t)*e);p=s+o/(1-t)*(1-i),l=Math.abs(c.lastPosition-p)<.1,a=o*i}else{a=null==c.lastVelocity?o:c.lastVelocity;const e=r.precision||(s==d?.005:Math.min(1,.001*Math.abs(d-s))),n=r.restVelocity||e/10,u=r.clamp?0:r.bounce,h=!i.is.und(u),f=s==d?c.v0>0:s<d;let m,y=!1;const g=1,_=Math.ceil(t/g);for(let t=0;t<_&&(m=Math.abs(a)>n,m||(l=Math.abs(d-p)<=e,!l));++t)h&&(y=p==d||p>d==f,y&&(a=-a*u,p=d)),a+=(1e-6*-r.tension*(p-d)+.001*-r.friction*a)/r.mass*g,p+=a*g}else{let i=1;r.duration>0&&(this._memoizedDuration!==r.duration&&(this._memoizedDuration=r.duration,c.durationProgress>0&&(c.elapsedTime=r.duration*c.durationProgress,e=c.elapsedTime+=t)),i=(r.progress||0)+e/this._memoizedDuration,i=i>1?1:i<0?0:i,c.durationProgress=i),p=s+r.easing(i)*(d-s),a=(p-c.lastPosition)/t,l=1==i}c.lastVelocity=a,Number.isNaN(p)&&(console.warn("Got NaN while animating:",this),l=!0)}u&&!u[h].done&&(l=!1),l?c.done=!0:e=!1,c.setValue(p,r.round)&&(s=!0)}));const c=(0,o.ys)(this),h=c.getValue();if(e){const t=(0,i.je)(n.to);h===t&&!s||r.decay?s&&r.decay&&this._onChange(h):(c.setValue(t),this._onChange(t)),this._stop()}else s&&this._onChange(h)}set(t){return i.Wn.batchedUpdates((()=>{this._stop(),this._focus(t),this._set(t)})),this}pause(){this._update({pause:!0})}resume(){this._update({pause:!1})}finish(){if(N(this)){const{to:t,config:e}=this.animation;i.Wn.batchedUpdates((()=>{this._onStart(),e.decay||this._set(t,!1),this._stop()}))}return this}update(t){return(this.queue||(this.queue=[])).push(t),this}start(t,e){let s;return i.is.und(t)?(s=this.queue||[],this.queue=[]):s=[i.is.obj(t)?t:r({},e,{to:t})],Promise.all(s.map((t=>this._update(t)))).then((t=>q(this,t)))}stop(t){const{to:e}=this.animation;return this._focus(this.get()),M(this._state,t&&this._lastCallId),i.Wn.batchedUpdates((()=>this._stop(e,t))),this}reset(){this._update({reset:!0})}eventObserved(t){"change"==t.type?this._start():"priority"==t.type&&(this.priority=t.priority+1)}_prepareNode(t){const e=this.key||"";let{to:s,from:n}=t;s=i.is.obj(s)?s[e]:s,(null==s||_(s))&&(s=void 0),n=i.is.obj(n)?n[e]:n,null==n&&(n=void 0);const r={to:s,from:n};return W(this)||(t.reverse&&([s,n]=[n,s]),n=(0,i.je)(n),i.is.und(n)?(0,o.ys)(this)||this._set(s):this._set(n)),r}_update(t,e){let s=r({},t);const{key:n,defaultProps:o}=this;s.default&&Object.assign(o,l(s,((t,e)=>/^on/.test(e)?c(t,n):t))),Y(this,s,"onProps"),K(this,"onProps",s,this);const a=this._prepareNode(s);if(Object.isFrozen(this))throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");const u=this._state;return k(++this._lastCallId,{key:n,props:s,defaultProps:o,state:u,actions:{pause:()=>{E(this)||($(this,!0),(0,i.bl)(u.pauseQueue),K(this,"onPause",R(this,F(this,this.animation.to)),this))},resume:()=>{E(this)&&($(this,!1),N(this)&&this._resume(),(0,i.bl)(u.resumeQueue),K(this,"onResume",R(this,F(this,this.animation.to)),this))},start:this._merge.bind(this,a)}}).then((t=>{if(s.loop&&t.finished&&(!e||!t.noop)){const t=L(s);if(t)return this._update(t,!0)}return t}))}_merge(t,e,s){if(e.cancel)return this.stop(!0),s(V(this));const n=!i.is.und(t.to),c=!i.is.und(t.from);if(n||c){if(!(e.callId>this._lastToId))return s(V(this));this._lastToId=e.callId}const{key:h,defaultProps:d,animation:l}=this,{to:p,from:f}=l;let{to:m=p,from:g=f}=t;!c||n||e.default&&!i.is.und(m)||(m=g),e.reverse&&([m,g]=[g,m]);const v=!(0,i.Xy)(g,f);v&&(l.from=g),g=(0,i.je)(g);const b=!(0,i.Xy)(m,p);b&&this._focus(m);const S=_(e.to),{config:w}=l,{decay:C,velocity:I}=w;(n||c)&&(w.velocity=0),e.config&&!S&&function(t,e,s){s&&(j(s=r({},s),e),e=r({},s,e)),j(t,e),Object.assign(t,e);for(const e in P)null==t[e]&&(t[e]=P[e]);let{mass:n,frequency:o,damping:a}=t;i.is.und(o)||(o<.01&&(o=.01),a<0&&(a=0),t.tension=Math.pow(2*Math.PI/o,2)*n,t.friction=4*Math.PI*a*n/o)}(w,a(e.config,h),e.config!==d.config?a(d.config,h):void 0);let k=(0,o.ys)(this);if(!k||i.is.und(m))return s(R(this,!0));const q=i.is.und(e.reset)?c&&!e.default:!i.is.und(g)&&u(e.reset,h),M=q?g:this.get(),U=y(m),A=i.is.num(U)||i.is.arr(U)||(0,i.Df)(U),x=!S&&(!A||u(d.immediate||e.immediate,h));if(b){const t=(0,o.sb)(m);if(t!==k.constructor){if(!x)throw Error(`Cannot animate between ${k.constructor.name} and ${t.name}, as the "to" prop suggests`);k=this._set(U)}}const Q=k.constructor;let z=(0,i.j$)(m),H=!1;if(!z){const t=q||!W(this)&&v;(b||t)&&(H=(0,i.Xy)(y(M),U),z=!H),((0,i.Xy)(l.immediate,x)||x)&&(0,i.Xy)(w.decay,C)&&(0,i.Xy)(w.velocity,I)||(z=!0)}if(H&&N(this)&&(l.changed&&!q?z=!0:z||this._stop(p)),!S&&((z||(0,i.j$)(p))&&(l.values=k.getPayload(),l.toValues=(0,i.j$)(m)?null:Q==o.eC?[1]:(0,i.qo)(U)),l.immediate!=x&&(l.immediate=x,x||q||this._set(p)),z)){const{onRest:t}=l;(0,i.S6)(J,(t=>Y(this,e,t)));const n=R(this,F(this,p));(0,i.bl)(this._pendingCalls,n),this._pendingCalls.add(s),l.changed&&i.Wn.batchedUpdates((()=>{l.changed=!q,null==t||t(n,this),q?a(d.onRest,n):null==l.onStart||l.onStart(n,this)}))}q&&this._set(M),S?s(T(e.to,e,this._state,this)):z?this._start():N(this)&&!b?this._pendingCalls.add(s):s(O(M))}_focus(t){const e=this.animation;t!==e.to&&((0,i.Ll)(this)&&this._detach(),e.to=t,(0,i.Ll)(this)&&this._attach())}_attach(){let t=0;const{to:e}=this.animation;(0,i.j$)(e)&&((0,i.UI)(e,this),x(e)&&(t=e.priority+1)),this.priority=t}_detach(){const{to:t}=this.animation;(0,i.j$)(t)&&(0,i.iL)(t,this)}_set(t,e=!0){const s=(0,i.je)(t);if(!i.is.und(s)){const t=(0,o.ys)(this);if(!t||!(0,i.Xy)(s,t.getValue())){const n=(0,o.sb)(s);t&&t.constructor==n?t.setValue(s):(0,o.f3)(this,n.create(s)),t&&i.Wn.batchedUpdates((()=>{this._onChange(s,e)}))}}return(0,o.ys)(this)}_onStart(){const t=this.animation;t.changed||(t.changed=!0,K(this,"onStart",R(this,F(this,t.to)),this))}_onChange(t,e){e||(this._onStart(),a(this.animation.onChange,t,this)),a(this.defaultProps.onChange,t,this),super._onChange(t,e)}_start(){const t=this.animation;(0,o.ys)(this).reset((0,i.je)(t.to)),t.immediate||(t.fromValues=t.values.map((t=>t.lastPosition))),N(this)||(D(this,!0),E(this)||this._resume())}_resume(){i.OH.skipAnimation?this.finish():i.fT.start(this)}_stop(t,e){if(N(this)){D(this,!1);const s=this.animation;(0,i.S6)(s.values,(t=>{t.done=!0})),s.toValues&&(s.onChange=s.onPause=s.onResume=void 0),(0,i.k0)(this,{type:"idle",parent:this});const n=e?V(this.get()):R(this.get(),F(this,null!=t?t:s.to));(0,i.bl)(this._pendingCalls,n),s.changed&&(s.changed=!1,K(this,"onRest",n,this))}}}function F(t,e){const s=y(e),n=y(t.get());return(0,i.Xy)(n,s)}function L(t,e=t.loop,s=t.to){let i=a(e);if(i){const n=!0!==i&&m(i),o=(n||t).reverse,a=!n||n.reset;return Z(r({},t,{loop:e,default:!1,pause:void 0,to:!o||_(s)?s:void 0,from:a?t.from:void 0,reset:a},n))}}function Z(t){const{to:e,from:s}=t=m(t),n=new Set;return i.is.obj(e)&&B(e,n),i.is.obj(s)&&B(s,n),t.keys=n.size?Array.from(n):null,t}function G(t){const e=Z(t);return i.is.und(e.default)&&(e.default=l(e)),e}function B(t,e){(0,i.rU)(t,((t,s)=>null!=t&&e.add(s)))}const J=["onStart","onRest","onChange","onPause","onResume"];function Y(t,e,s){t.animation[s]=e[s]!==h(e,s)?c(e[s],t.key):void 0}function K(t,e,...s){var i,n,o,r;null==(i=(n=t.animation)[e])||i.call(n,...s),null==(o=(r=t.defaultProps)[e])||o.call(r,...s)}const tt=["onStart","onChange","onRest"];let et=1;class st{constructor(t,e){this.id=et++,this.springs={},this.queue=[],this.ref=void 0,this._flush=void 0,this._initialProps=void 0,this._lastAsyncId=0,this._active=new Set,this._changed=new Set,this._started=!1,this._item=void 0,this._state={paused:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set},this._events={onStart:new Map,onChange:new Map,onRest:new Map},this._onFrame=this._onFrame.bind(this),e&&(this._flush=e),t&&this.start(r({default:!0},t))}get idle(){return!this._state.asyncTo&&Object.values(this.springs).every((t=>t.idle))}get item(){return this._item}set item(t){this._item=t}get(){const t={};return this.each(((e,s)=>t[s]=e.get())),t}set(t){for(const e in t){const s=t[e];i.is.und(s)||this.springs[e].set(s)}}update(t){return t&&this.queue.push(Z(t)),this}start(t){let{queue:e}=this;return t?e=(0,i.qo)(t).map(Z):this.queue=[],this._flush?this._flush(this,e):(ct(this,e),it(this,e))}stop(t,e){if(t!==!!t&&(e=t),e){const s=this.springs;(0,i.S6)((0,i.qo)(e),(e=>s[e].stop(!!t)))}else M(this._state,this._lastAsyncId),this.each((e=>e.stop(!!t)));return this}pause(t){if(i.is.und(t))this.start({pause:!0});else{const e=this.springs;(0,i.S6)((0,i.qo)(t),(t=>e[t].pause()))}return this}resume(t){if(i.is.und(t))this.start({pause:!1});else{const e=this.springs;(0,i.S6)((0,i.qo)(t),(t=>e[t].resume()))}return this}each(t){(0,i.rU)(this.springs,t)}_onFrame(){const{onStart:t,onChange:e,onRest:s}=this._events,n=this._active.size>0,o=this._changed.size>0;(n&&!this._started||o&&!this._started)&&(this._started=!0,(0,i.yl)(t,(([t,e])=>{e.value=this.get(),t(e,this,this._item)})));const r=!n&&this._started,a=o||r&&s.size?this.get():null;o&&e.size&&(0,i.yl)(e,(([t,e])=>{e.value=a,t(e,this,this._item)})),r&&(this._started=!1,(0,i.yl)(s,(([t,e])=>{e.value=a,t(e,this,this._item)})))}eventObserved(t){if("change"==t.type)this._changed.add(t.parent),t.idle||this._active.add(t.parent);else{if("idle"!=t.type)return;this._active.delete(t.parent)}i.Wn.onFrame(this._onFrame)}}function it(t,e){return Promise.all(e.map((e=>nt(t,e)))).then((e=>q(t,e)))}async function nt(t,e,s){const{keys:n,to:o,from:r,loop:a,onRest:u,onResolve:c}=e,d=i.is.obj(e.default)&&e.default;a&&(e.loop=!1),!1===o&&(e.to=null),!1===r&&(e.from=null);const l=i.is.arr(o)||i.is.fun(o)?o:void 0;l?(e.to=void 0,e.onRest=void 0,d&&(d.onRest=void 0)):(0,i.S6)(tt,(s=>{const n=e[s];if(i.is.fun(n)){const i=t._events[s];e[s]=({finished:t,cancelled:e})=>{const s=i.get(n);s?(t||(s.finished=!1),e&&(s.cancelled=!0)):i.set(n,{value:null,finished:t||!1,cancelled:e||!1})},d&&(d[s]=e[s])}}));const p=t._state;e.pause===!p.paused?(p.paused=e.pause,(0,i.bl)(e.pause?p.pauseQueue:p.resumeQueue)):p.paused&&(e.pause=!0);const f=(n||Object.keys(t.springs)).map((s=>t.springs[s].start(e))),m=!0===e.cancel||!0===h(e,"cancel");(l||m&&p.asyncId)&&f.push(k(++t._lastAsyncId,{props:e,state:p,actions:{pause:i.ZT,resume:i.ZT,start(e,s){m?(M(p,t._lastAsyncId),s(V(t))):(e.onRest=u,s(T(l,e,p,t)))}}})),p.paused&&await new Promise((t=>{p.resumeQueue.add(t)}));const y=q(t,await Promise.all(f));if(a&&y.finished&&(!s||!y.noop)){const s=L(e,a,o);if(s)return ct(t,[s]),nt(t,s,!0)}return c&&i.Wn.batchedUpdates((()=>c(y,t,t.item))),y}function ot(t,e){const s=r({},t.springs);return e&&(0,i.S6)((0,i.qo)(e),(t=>{i.is.und(t.keys)&&(t=Z(t)),i.is.obj(t.to)||(t=r({},t,{to:void 0})),ut(s,t,(t=>at(t)))})),rt(t,s),s}function rt(t,e){(0,i.rU)(e,((e,s)=>{t.springs[s]||(t.springs[s]=e,(0,i.UI)(e,t))}))}function at(t,e){const s=new X;return s.key=t,e&&(0,i.UI)(s,e),s}function ut(t,e,s){e.keys&&(0,i.S6)(e.keys,(i=>{(t[i]||(t[i]=s(i)))._prepareNode(e)}))}function ct(t,e){(0,i.S6)(e,(e=>{ut(t.springs,e,(e=>at(e,t)))}))}const ht=["children"],dt=t=>{let{children:e}=t,s=function(t,e){if(null==t)return{};var s,i,n={},o=Object.keys(t);for(i=0;i<o.length;i++)s=o[i],e.indexOf(s)>=0||(n[s]=t[s]);return n}(t,ht);const o=(0,n.useContext)(lt),r=s.pause||!!o.pause,a=s.immediate||!!o.immediate;s=(0,i.Pr)((()=>({pause:r,immediate:a})),[r,a]);const{Provider:u}=lt;return n.createElement(u,{value:s},e)},lt=(pt=dt,ft={},Object.assign(pt,n.createContext(ft)),pt.Provider._context=pt,pt.Consumer._context=pt,pt);var pt,ft;dt.Provider=lt.Provider,dt.Consumer=lt.Consumer;const mt=()=>{const t=[],e=function(e){(0,i.ZR)();const n=[];return(0,i.S6)(t,((t,o)=>{if(i.is.und(e))n.push(t.start());else{const i=s(e,t,o);i&&n.push(t.start(i))}})),n};e.current=t,e.add=function(e){t.includes(e)||t.push(e)},e.delete=function(e){const s=t.indexOf(e);~s&&t.splice(s,1)},e.pause=function(){return(0,i.S6)(t,(t=>t.pause(...arguments))),this},e.resume=function(){return(0,i.S6)(t,(t=>t.resume(...arguments))),this},e.set=function(e){(0,i.S6)(t,(t=>t.set(e)))},e.start=function(e){const s=[];return(0,i.S6)(t,((t,n)=>{if(i.is.und(e))s.push(t.start());else{const i=this._getProps(e,t,n);i&&s.push(t.start(i))}})),s},e.stop=function(){return(0,i.S6)(t,(t=>t.stop(...arguments))),this},e.update=function(e){return(0,i.S6)(t,((t,s)=>t.update(this._getProps(e,t,s)))),this};const s=function(t,e,s){return i.is.fun(t)?t(s,e):t};return e._getProps=s,e};function yt(t,e,s){const o=i.is.fun(e)&&e;o&&!s&&(s=[]);const a=(0,n.useMemo)((()=>o||3==arguments.length?mt():void 0),[]),u=(0,n.useRef)(0),c=(0,i.NW)(),h=(0,n.useMemo)((()=>({ctrls:[],queue:[],flush(t,e){const s=ot(t,e);return u.current>0&&!h.queue.length&&!Object.keys(s).some((e=>!t.springs[e]))?it(t,e):new Promise((i=>{rt(t,s),h.queue.push((()=>{i(it(t,e))})),c()}))}})),[]),d=(0,n.useRef)([...h.ctrls]),l=[],p=(0,i.zH)(t)||0,f=d.current.slice(t,p);function m(t,s){for(let i=t;i<s;i++){const t=d.current[i]||(d.current[i]=new st(null,h.flush)),s=o?o(i,t):e[i];s&&(l[i]=G(s))}}(0,n.useMemo)((()=>{d.current.length=t,m(p,t)}),[t]),(0,n.useMemo)((()=>{m(0,Math.min(p,t))}),s);const y=d.current.map(((t,e)=>ot(t,l[e]))),_=(0,n.useContext)(dt),S=(0,i.zH)(_),P=_!==S&&g(_);(0,i.bt)((()=>{u.current++,h.ctrls=d.current;const{queue:t}=h;t.length&&(h.queue=[],(0,i.S6)(t,(t=>t()))),(0,i.S6)(f,(t=>{v(t,a),t.stop(!0)})),(0,i.S6)(d.current,((t,e)=>{null==a||a.add(t),P&&t.start({default:_});const s=l[e];s&&(b(t,s.ref),t.ref?t.queue.push(s):t.start(s))}))})),(0,i.tf)((()=>()=>{(0,i.S6)(h.ctrls,(t=>t.stop(!0)))}));const w=y.map((t=>r({},t)));return a?[w,a]:w}function gt(t,e){const s=i.is.fun(t),[[n],o]=yt(1,s?t:[t],s?e||[]:e);return s||2==arguments.length?[n,o]:n}let _t;!function(t){t.MOUNT="mount",t.ENTER="enter",t.UPDATE="update",t.LEAVE="leave"}(_t||(_t={}));class vt extends z{constructor(t,e){super(),this.key=void 0,this.idle=!0,this.calc=void 0,this._active=new Set,this.source=t,this.calc=(0,i.mD)(...e);const s=this._get(),n=(0,o.sb)(s);(0,o.f3)(this,n.create(s))}advance(t){const e=this._get(),s=this.get();(0,i.Xy)(e,s)||((0,o.ys)(this).setValue(e),this._onChange(e,this.idle)),!this.idle&&St(this._active)&&Pt(this)}_get(){const t=i.is.arr(this.source)?this.source.map(i.je):(0,i.qo)((0,i.je)(this.source));return this.calc(...t)}_start(){this.idle&&!St(this._active)&&(this.idle=!1,(0,i.S6)((0,o.He)(this),(t=>{t.done=!1})),i.OH.skipAnimation?(i.Wn.batchedUpdates((()=>this.advance())),Pt(this)):i.fT.start(this))}_attach(){let t=1;(0,i.S6)((0,i.qo)(this.source),(e=>{(0,i.j$)(e)&&(0,i.UI)(e,this),x(e)&&(e.idle||this._active.add(e),t=Math.max(t,e.priority+1))})),this.priority=t,this._start()}_detach(){(0,i.S6)((0,i.qo)(this.source),(t=>{(0,i.j$)(t)&&(0,i.iL)(t,this)})),this._active.clear(),Pt(this)}eventObserved(t){"change"==t.type?t.idle?this.advance():(this._active.add(t.parent),this._start()):"idle"==t.type?this._active.delete(t.parent):"priority"==t.type&&(this.priority=(0,i.qo)(this.source).reduce(((t,e)=>Math.max(t,(x(e)?e.priority:0)+1)),0))}}function bt(t){return!1!==t.idle}function St(t){return!t.size||Array.from(t).every(bt)}function Pt(t){t.idle||(t.idle=!0,(0,i.S6)((0,o.He)(t),(t=>{t.done=!0})),(0,i.k0)(t,{type:"idle",parent:t}))}i.OH.assign({createStringInterpolator:i.qS,to:(t,e)=>new vt(t,e)}),i.fT.advance}}]);